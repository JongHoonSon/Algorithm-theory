// 미로 탈출 : 문제 설명

// 동빈이는 N x M 크기의 직사각형 형태의 미로에 갇혔습니다. 미로에는
// 여러 마리의 괴물이 있어 이를 피해 탈출해야 합니다. 동빈이의 위치는
// (1, 1)이며 미로의 출구는 (N, M)의 위치에 존재하며 한 번에 한 칸씩
// 이동할 수 있습니다. 이때 괴물이 있는 부분은 0으로, 괴물이 없는 부분은
// 1로 표시되어 있습니다. 미로는 반드시 탈출할 수 있는 형태로 제시됩니다.
// 이때 동빈이가 탈출하기 위해 움직여야 하는 최소 칸의 개수를 구하세요.
// 칸을 셀 때는 시작 칸과 마지막 칸을 모두 포함해서 계산합니다.

// 출처 : https://youtu.be/7C9RgOcvkvo?t=3077 (유튜브 나동빈)

const N = 5;
const M = 6;

const graph = new Array(N);
const queue = [];
let di = [];
let dj = [];

// 이동 가능한 곳 (di, dj의 index 값 이용)
di = [-1, 1, 0, 0];
dj = [0, 0, -1, 1];

// 값 넣기
graph[0] = [1, 0, 1, 0, 1, 0];
graph[1] = [1, 1, 1, 1, 1, 1];
graph[2] = [0, 0, 0, 0, 0, 1];
graph[3] = [1, 1, 1, 1, 1, 1];
graph[4] = [1, 1, 1, 1, 1, 1];

for (let i = 0; i < N; i++) {
  console.log("graph[i]", graph[i]);
}

console.log(BFS(0, 0));

for (let i = 0; i < N; i++) {
  console.log("graph[i]", graph[i]);
}

function BFS(firstI, firstJ) {
  // 큐에 현재 위치(첫 시작 위치)를 방문 처리 (BFS에서 방문 처리 = 큐에 넣기)
  // BFS는 어차피 한 번 수행되는 함수이므로 첫 시작 위치를 큐에 넣는 것과 방문처리 하는 것은
  // 함수 밖에서 미리 수행해도 상관 없음
  queue.push(firstI);
  queue.push(firstJ);

  // 큐가 빌 때까지 진행
  while (queue.length !== 0) {
    // 큐의 맨 앞에서 값 꺼내기
    const i = queue.shift();
    const j = queue.shift();

    // di와 dj의 index k에 있는 수만큼 i, j를 이동시킨 위치를 ni, nj에 저장
    for (let k = 0; k < 4; k++) {
      const ni = i + di[k];
      const nj = j + dj[k];

      // (ni, nj)가 탐색 범위에서 벗어난 곳이면
      if (ni <= -1 || ni >= N || nj <= -1 || nj >= M) {
        // 넘어감
        continue;
      }

      // (ni, nj)가 탐색할 수 없는 곳이면 (괴물이 있는 곳, graph[ni][nj]의 값이 0)
      if (graph[ni][nj] === 0) {
        // 넘어감
        continue;
      }

      // (ni, nj)가 방문할 수 있는 곳이면 (graph[ni][nj]의 값이 1이고, 시작점이 아니면) 방문함
      // (이미 방문된 곳의 값은 1보다 높아졌기 때문에 조건을 만족하지 않아 넘어감)
      if (graph[ni][nj] === 1 && (ni !== firstI || nj !== firstJ)) {
        // (0,0)부터 이전 위치(i,j)까지 이동한 최단거리(graph[i][j])에 +1한 값을
        // (ni, nj)까지 이동하는 최단거리로 설정 (graph[ni][nj]에 저장)
        graph[ni][nj] = graph[i][j] + 1;

        // 해당 위치를 방문처리함 (BFS에서 방문 처리 = 큐에 넣기)
        queue.push(ni);
        queue.push(nj);
      }
    }
  }

  // 오른쪽 맨 밑까지의 최단 거리 반환
  return graph[N - 1][M - 1];
}

// 동작 원리

// 1. 첫 시작점을 곳을 큐에 넣는다.

// --- 반복1 --- (큐가 빌 때까지)
// 2. 큐의 맨 앞에서 하나를 꺼낸다. (좌표 A라고 부름)
//    --- 반복2 --- (탐색 조건에 해당하는 곳 모두)
//    3. 좌표 A를 기준으로 탐색을 시작한다. (탐색 조건은 문제마다 다름, 여기서는 상하좌우)
//    4. 만약 범위에서 벗어난 곳에 방문했을 경우, continue로 빠져나온다.
//    5. 마찬가지로 방문하지 못하는 곳(문제 조건)에 방문했을 경우, continue로 빠져나온다.
//    6. 방문을 해도 되는 곳이면, 해당 지점을 방문한다. (해당 지점의 graph의 계산해서 넣기 (최단거리))
//    7. 해당 지점을 방문 처리한다. (=방문 처리 =큐에 넣는다)
//    --- 반복2 ---
// --- 반복1 ---

// 8. 마지막으로 graph의 맨 오른쪽 아래를 출력하면, 해당 지점까지 가는 최단 거리를 구할 수 있다.

// BFS 특징

// 1. 해당 지점을 방문했는지를 기록하기 위한 check[] 배열이 필요 없다.
// => 방문을 하기 위한 조건은 해당 지점의 값이 1일 경우인데,
//  방문을 이미 한 곳의 값은 1보다 커져있다.
//  따라서 다시 방문할 가능성이 없어지므로 check[]를 사용할 필요가 없다.

// 2. 각 지점의 값이 최단 거리의 값이 되는 이유
// => 이미 그 지점의 바로 이전 지점의 값은 1보다 클 것이다. (시작점 제외)
//  그러면, 새로 도착한 지점에서 주변에 1인 값을 찾는 과정만 반복하면 되므로
//  최단 거리의 값을 갱신하기 때문에 항상 방문가능한 모든 지점의 값이 최단 거리의 값이 된다.
//  (똑부러지게 설명을 못하겠음)

// 3. 탐색이 종료된 후, 첫 시작점은 값이 1이 아닌 3이 된다.
// => 이 문제에서 첫 탐색 과정을 보면 시작점에서 밑으로 이동한 후에,
//  밑에서 다시 상하좌우를 판단했을 때 위에 있는 시작점의 값이 1이기 때문에 다시 방문한다.
//  이런 현상을 없애기 위해서는 방문 조건에 방문할 곳이 시작점(firstI, firstJ)인지 판단하는 조건을 넣으면 된다.
