// 퀵 정렬 : 기준 데이터(Pivot)를 설정하고
// 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법

// 탐색 과정

// 5 7 9 0 3 1 6 2 4 8      => 0번 index에 들어있는 7을 피벗으로 삼음

// 5 '7' 9 0 3 1 6 2 '4' 8
//                          => 피벗의 오른쪽에 존재하는 요소 중에서
//                             첫번째 index의 값인 5부터 오른쪽으로 진행하면서 피벗인 5보다 더 큰 값인 7을,
//                             마지막 index의 값인 8부터 왼쪽으로 진행하면서 피벗인 5보다 더 작은 값인 4을 찾음
//                             큰 값인 7이 작은 값인 4보다 더 왼쪽에서 발견되었으므로 (index가 작으므로)
//                             서로 교환함
// 5 '4' 9 0 3 1 6 2 '7' 8

// 5 4 '9' 0 3 1 6 '2' 7 8
//                          => 피벗의 오른쪽에 존재하는 요소 중에서
//                             첫번째 index의 값인 5부터 오른쪽으로 진행하면서 피벗인 5보다 더 큰 값인 9을,
//                             마지막 index의 값인 8부터 왼쪽으로 진행하면서 피벗인 5보다 더 작은 값인 2을 찾음
//                             큰 값인 9가 작은 값인 2보다 더 왼쪽에서 발견되었으므로 (index가 작으므로)
//                             서로 교환함
// 5 4 '2' 0 3 1 6 '9' 7 8

// 5 4 2 0 3 '1' '6' 9 7 8
//                          => 피벗의 오른쪽에 존재하는 요소 중에서
//                             첫번째 index의 값인 5부터 오른쪽으로 진행하면서 피벗인 5보다 더 큰 값인 6을,
//                             마지막 index의 값인 8부터 왼쪽으로 진행하면서 피벗인 5보다 더 작은 값인 1을 찾음
//                             큰 값인 9가 작은 값인 2보다 더 오른쪽에서 발견되었으므로 (index가 더 크므로)
//                             서로 교환하지 않고, 다음 과정을 따름

// '5' 4 2 0 3 '1' 6 9 7 8
//                          => 1. 작은 값과 피벗의 위치를 교환함
// '1' 4 2 0 3 '5' 6 9 7 8

// 1 4 2 0 3 '5' 6 9 7 8
//                          => 2. 피벗을 기준으로 좌우 배열을 나눔 (좌측은 피벗보다 작은 수로 이루어지고, 우측은 피벗보다 큰 수로 이루어짐)
// [1 4 2 0 3] '5' [6 9 7 8]

// ['1' 4 2 0 3] 5 ['6' 9 7 8]
//                          => 3. 각 배열의 첫 원소를 피벗으로 설정해 또 다시 퀵정렬 수행 (재귀)
// [...] 5 [...]

// 시간복잡도 : 분할이 일어날 때마다 각 배열의 원소의 수 (탐색해야하는 수의 갯수)가 절반씩 줄어들기 때문에
//              => O(N x logN)
