let fs = require("fs");
let input = fs.readFileSync("./dev/stdin").toString().trim().split(" ");

const N = +input[0];
const M = +input[1];

// 1부터 N까지의 수를 담은 배열
let arr = [];

// 1부터 N까지 현재까지 방문했던 곳을 true, 방문하지 않은 곳을 false로 갖는 배열
// 각 단계에서 해당 문자를 취해도 되는지 안되는지를 저장하고 있다.
// 만약 문자를 중복해서 고를 수 있다면 사용하지 않아야 한다. (ex) AAA)
let check = [];

// 찾은 문자열을 저장하는 곳, 최종 답
let answer = [];

// 먼저 arr와 check를 초기 값을 넣어줌,
// arr은 1부터 N까지의 수
// check는 false
for (let i = 1; i <= N; i++) {
  arr.push(i);
  check.push(false);
}

// 단계별로 찾은 문자를 저장할 배열
let string = [];

// BT 함수로 첫번째 문자부터 탐색 시작
// 같이 전달하는 배열의 index = 0에 들어가야 하는 값이므로
// 1이 아닌 0을 전달
BT(0);
console.log(answer.join("\n"));

function BT(step) {
  // 1. 종료 조건 파트
  // step를 step+1로 1씩 증가시켜 탐색을 진행한다.
  // step이 0일 경우 첫번째 문자를 탐색, step이 1일 경우 두번째 문자를 탐색 ...
  // 만약 M=3 이고, step 값이 3인 BT 함수가 호출되었다면

  // 3번째 문자까지 모두 다 찾고 4번째 문자를 찾으려 하는 것이고, (i번째 문자를 찾는 step 은 i-1임을 고려.)
  // 이는 문제에서 조건으로 주어진 3개의 문자로 이루어진 string을 이미 만들었다는 뜻이되므로
  // 더 이상 탐색을 진행할 필요가 없다.
  // 따라서 여태까지 찾았던 3개의 문자로 이루어진 string을 answer에 넣어준 후
  // return 으로 함수를 종료시켜준다.
  if (step === M) {
    answer.push(string.join(" "));
    return;
  }

  // 2. 각 단계 별 process 파트
  // 함수 호출 1회당 1개의 문자를 찾는 단계가 진행된다.
  // 각 단계는 step+1 번째 문자를 찾는 과정이다.
  // 총 M개 문자로 이루어진 문자열을 만들어야 하므로 총 M단계까지 진행된다.

  // 각 단계에서는 arr에 들어있는 수를 선택할지 말지 결정해야 한다. (* 결정할때는 check 배열의 true, false를 참고)
  // 따라서 arr의 첫번째 index 0부터 마지막 index N-1까지 반목문으로 탐색한다.

  // 만약 문제의 조건에 수열이 오름차순 또는 내림차순이어야 한다는 조건이 있다면,
  // 먼저 arr를 정렬한 뒤에
  // BT의 매개변수에 단계별로 찾은 값의 index를 저장하는 매개변수 min를 추가로 넣는다.
  // 그리고 반복문의 시작 값을 i=0이 아닌 i=min으로 하여, 이전 단계에서 찾은 index인 min보다
  // 다음 index부터 탐색을 시작한다.
  for (let i = 0; i < N; i++) {
    // 2-1. 이미 선택된 적이 있는지 체크
    // 만일 i번째 index가 앞선 단계에서 선택되었다면
    if (check[i] === true) {
      // 다음 index로 넘어간다.
      continue;
    }

    // 2-2. 선택
    // 과정 1의 조건문에 걸리지 않은 경우, 선택된 적이 없는 index이므로
    // 해당 수를 string에 push하고 (선택함),
    // check에 해당 index가 선택되었다는 것을 기록한다.
    string.push(arr[i]);
    check[i] = true;

    // 2-1, 2-2는 반목문에 의해 배열 arr의 처음부터 끝까지 모든 요소에 대해 진행된다.

    // 3. 재귀함수 호출 파트
    // 파트 2에서 위의 두 줄에서, 현재 단계에서 넣을 수 있는 문자를 찾았으므로,
    // 다음 단계로 진행하기 위해 step를 +1로 다음 단계를 호출한다.

    // 만약 문제의 조건에 수열이 오름차순 또는 내림차순이어야 한다는 조건이 있다면,
    // 위에서 설명한 매개변수 min값을 이용하기 위해, 현재 찾은 값의 index인 i값을 다음 단계의 BT에 전달한다  => BT(step + 1, i);
    BT(step + 1);

    // 4. 재귀함수 후처리 파트
    // 각 재귀함수가 종료된 후 처리해줘야 할 것을 적는 파트이다.
    // 이 문제에서 함수의 종료 조건은 step===M 의 조건에 걸렸을 때인데,
    // 해당 조건에 걸렸을 경우
    // 해당 시점까지 찾은 M개의 문자로 이루어진 string 문자열을 answer에 넣고 return 하였으므로

    // check[i]에 false를 넣고, string의 마지막 문자를 pop 한다.
    // string.pop()을 함수의 첫 부분에 if문에서 step===M 조건에 걸리고 나서가 아닌
    // 재귀호출된 BT가 종료되고나서, 여기서 해주어야하는 이유는
    // string.pop()이 문자를 모두 찾았을 경우 뿐만 아니라
    // 문자를 못찾아서 다음 반복문으로 넘어가야할 경우에도 진행해야하기 때문이다.
    // 자세히 설명하면 아래와 갔다.

    // 먼저, 종료조건의 if문에서 string.pop()을 한 경우, 아래처럼 마지막 숫자만 pop이 된다.
    // 1 2 3(pop)
    // 1 2 4(pop)
    // 1 2 5(pop)

    // 이후 1 3으로 시작하는 수열을 찾기 위해서는
    // step1에서 찾은 2를 pop하고, step1에서의 반복문의 i 값이 1에서 2로 증가하여
    // arr[2]인 3을 string에 push해야 string의 값이 [1, 3]이 된다.

    // 하지만 종료조건에서 step===M 인 경우에만 string.pop()을 수행하기 때문에
    // 1 2에서 2가 pop되지 못하고, 1 2 뒤에 바로 3이 붙어 string의 값이 [1, 2, 3]이 된다.
    // 이는 step1에서 찾은 문자를 제대로 pop하지 못하고, step1의 다음 과정을 진행했기 때문이다.
    // 따라서 이런 상황을 방지하기 위해 string.pop()의 위치는 BT 재귀함수가 종료되고 나서인
    // BT 재귀함수의 호출문 아래에 적는다.

    // 그렇게 하면 다음 경우에 모두 string.pop()이 동작한다.
    // 경우 1) 종료 조건을 만족하여 마지막 수를 빼야하는 경우
    // 경우 2) N-1 미만의 단계(중간단계)에서 다음 수로 탐색을 넘어가기 위해 기존 수를 빼고 넣어야하는 경우

    // -> 함수 초반 if문에서 step===M 조건에 걸리고 재귀 함수 호출이 끝나게 되면
    check[i] = false;
    string.pop();
  }
}
