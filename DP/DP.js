// DP는 다음 두 가지 조건이 만족할 때 사용할 수 있다.

// 1. 최적 부분 구조
// : 큰 문제를 작은 문제로 나눌 수 있으며,
// 작은 문제의 답을 모아서 큰 문제를 해결할 수 있어야 한다.

// 2. 중복되는 부분 문제
// : 동일한 작은 문제를 반복적으로 해결할 수 있어야 한다.

// DP에서 사용하는 핵심 기법 : 메모이제이션 (Memoization)

// 문제의 답을 구하는 과정에서 여러번 계산해야하는 동일한 문제가 있다면
// 해당 문제를 푼 결과 값을 배열에 저장하고,
// 추후에 해당 문제를 풀어야할 때, 저장한 값을 이용해서
// 연산을 최소화 하는 방식

// DP는 두 가지 방식으로 나눌 수 있다.

// 1. 바텀업 방식 (상향식)
// : D[i]를 구하기 위해서
// 바로 앞의 D[i-1], D[i-2]... 을 이용해서
// D[x]까지 하나씩 값을 구해나가는 방식

// ex) 100까지의 피보나치 수열 값 구하기 문제를
// 바텁업 방식으로 풀기

let D = new Array(101).fill(0);

D[1] = 1;
D[2] = 2;

for (let i = 3; i <= 100; i++) {
  // 이전에 계산한 값을 누적함 (메모이제이션)
  D[i] = D[i - 1] + D[i - 2];
}

console.log(D[100]);

// 2. 탑다운 방식 (하향식)
// : D[x]를 구하기 위해서
// D[x-1], D[x-2], ..., D[1], D[0] 방향으로 재귀를 호출하고
// D[0], D[1], ..., D[x-2], D[x-1] 방향으로 계산하여
// D[x]까지 하나씩 값을 구해나가는 방식
// *재귀호출을 이용한다는 특징이 있음

// ex) 100까지의 피보나치 수열 값 구하기 문제를
// 바텁업 방식으로 풀기

let D = new Array(101).fill(0);

function DP(x) {
  // 종료 조건
  if (x === 1 || x === 2) {
    return 1;
  }

  // 이미 계산한 적 있으면, 계산한 값 사용 (메모이제이션)
  if (D[x] !== 0) {
    return D[x];
  }

  // D[x]를 구하는 과정에서 D[x-1], D[x-2]를 이용하기 위해
  // D[x-1]을 구하는 DP(x-1)과
  // D[x-2]를 구하는 DP(x-2)를 재귀 호출함
  D[x] = DP(x - 1) + DP(x - 2);

  // 이번 함수 단계에서 구해야 하는 D[x]를 반환
  return D[x];
}

console.log(DP(100));
